// Ver4.4 - Webhook + discovery fixes
import groovy.json.JsonBuilder

metadata {
    definition(name: "Connector Bridge (HTTP)", namespace: "Connector", author: "ScubaMikeJax904") {
        capability "Refresh"
        command "refreshDevices"
        command "pingBridge"
        command "testWebhook"
        attribute "bridgeStatus", "string"
        attribute "lastDiscovery", "string"
        attribute "webhookStatus", "string"
    }
}

/*
 * REQUIRED so Hubitat actually exposes the callback endpoint
 */
mappings {
    path("/callback/connector-bridge-${device.id}") {
        action: [
            POST: "callback"
        ]
    }
}

preferences {
    input name: "serverIP", type: "string", title: "Node.js Server IP", required: true
    input name: "serverPort", type: "number", title: "Node.js Server Port", defaultValue: 3069, required: true
    input name: "pollInterval", type: "number", title: "Polling interval (minutes)", defaultValue: 5, required: true
    input name: "pingInterval", type: "number", title: "Bridge health check interval (minutes)", defaultValue: 1, required: true
    input name: "logEnable", type: "bool", title: "Enable Debug Logging?", defaultValue: true
    input name: "useWebhook", type: "bool", title: "Enable webhook for real-time updates", defaultValue: true
}

// ------------------- Initialization -------------------
def installed() {
    refreshDevices()
    schedulePolling()
    schedulePing()
    registerWebhook()
}

def updated() {
    unschedule()
    refreshDevices()
    schedulePolling()
    schedulePing()
    registerWebhook()
}

def refresh() {
    refreshDevices()
}

// ------------------- Bridge Ping / Health -------------------
def pingBridge() {
    if (!serverIP || !serverPort) return
    if (logEnable) log.debug "Pinging Node.js bridge..."

    def url = "http://${serverIP}:${serverPort}/devices"
    try {
        httpGet(url) { resp ->
            if (resp.status == 200) {
                sendEvent(name: "bridgeStatus", value: "ok")
                getChildDevices().each { it.sendEvent(name: "online", value: "online") }
            } else {
                sendEvent(name: "bridgeStatus", value: "offline")
                getChildDevices().each { it.markOffline() }
            }
        }
    } catch (e) {
        log.error "Bridge ping error: ${e.message}"
        sendEvent(name: "bridgeStatus", value: "offline")
        getChildDevices().each { it.markOffline() }
    }
}

def schedulePing() {
    unschedule("pingBridge")
    switch (pingInterval ?: 1) {
        case 1: runEvery1Minute("pingBridge"); break
        case 5: runEvery5Minutes("pingBridge"); break
        case 10: runEvery10Minutes("pingBridge"); break
        case 15: runEvery15Minutes("pingBridge"); break
        case 30: runEvery30Minutes("pingBridge"); break
        case 60: runEvery1Hour("pingBridge"); break
        default: runEvery5Minutes("pingBridge")
    }
}

// ------------------- Webhook Registration -------------------
def registerWebhook() {
    if (!useWebhook) {
        sendEvent(name: "webhookStatus", value: "disabled")
        return
    }

    def callbackUrl = getHubitatCallbackUrl()
    if (logEnable) log.debug "Registering webhook: ${callbackUrl}"

    try {
        httpPost(
            uri: "http://${serverIP}:${serverPort}/webhook",
            body: new JsonBuilder([callbackUrl: callbackUrl]).toString(),
            requestContentType: "application/json"
        ) { resp ->
            sendEvent(
                name: "webhookStatus",
                value: resp.status == 200 ? "registered" : "error"
            )
        }
    } catch (e) {
        log.error "Webhook registration failed: ${e.message}"
        sendEvent(name: "webhookStatus", value: "error")
    }
}

def testWebhook() {
    try {
        httpPost(uri: "http://${serverIP}:${serverPort}/webhook/test") { resp ->
            sendEvent(
                name: "webhookStatus",
                value: resp.status == 200 ? "registered" : "error"
            )
        }
    } catch (e) {
        log.error "Webhook test failed: ${e.message}"
        sendEvent(name: "webhookStatus", value: "error")
    }
}

def getHubitatCallbackUrl() {
    return "http://${location.hub.localIP}:39500/callback/connector-bridge-${device.id}"
}

// ------------------- Webhook Callback Handler -------------------
def callback() {
    def payload = request?.JSON
    if (!payload?.mac || !payload?.data) {
        render status: 400, data: "Invalid payload"
        return
    }

    updateChildState(payload.mac, payload.data)
    render status: 200, data: "OK"
}

// ------------------- Device Discovery -------------------
def refreshDevices() {
    if (logEnable) log.debug "Refreshing devices from Node.js server"

    try {
        httpGet("http://${serverIP}:${serverPort}/devices") { resp ->
            if (resp.status != 200 || !resp.data?.devices) return

            resp.data.devices.each { mac, dev ->
                def child = getChildDevice(mac)
                if (!child) {
                    addChildDevice(
                        "Connector",
                        "Connector Bridge Roller Child",
                        mac,
                        [label: dev?.friendlyName ?: "Blind ${mac}", isComponent: false]
                    )
                }
                requestStatus(mac)
            }

            sendEvent(
                name: "lastDiscovery",
                value: new Date().format("yyyy-MM-dd HH:mm:ss", location.timeZone)
            )
        }
    } catch (e) {
        log.error "Device refresh failed: ${e.message}"
    }
}

// ------------------- Status Request -------------------
def requestStatus(mac) {
    try {
        httpGet("http://${serverIP}:${serverPort}/status/${mac}") { resp ->
            if (resp.status == 200 && resp.data) {
                updateChildState(mac, resp.data)
            }
        }
    } catch (e) {
        log.error "Status request error for ${mac}: ${e.message}"
    }
}

// ------------------- Child State Update -------------------
def updateChildState(mac, data) {
    def child = getChildDevice(mac)
    if (!child) {
        addChildDevice(
            "Connector",
            "Connector Bridge Roller Child",
            mac,
            [label: "Blind ${mac}", isComponent: false]
        )
        child = getChildDevice(mac)
    }

    child?.updateStateFromParent(data)

    if (logEnable && child) {
        log.debug "Updated ${child.displayName} â†’ pos=${data.currentPosition ?: "?"}%, battery=${data.batteryLevel ?: "?"}%, rssi=${data.raw?.RSSI ?: "?"}"
    }
}

// ------------------- Move Commands -------------------
def sendMoveCommand(mac, Map body) {
    try {
        httpPost(
            uri: "http://${serverIP}:${serverPort}/move/${mac}",
            body: new JsonBuilder(body).toString(),
            requestContentType: "application/json"
        )
    } catch (e) {
        log.error "Move command error for ${mac}: ${e.message}"
    }
}

def sendOpenCommand(mac)  { sendMoveCommand(mac, [operation: 1]) }
def sendCloseCommand(mac) { sendMoveCommand(mac, [operation: 0]) }
def sendStopCommand(mac)  { sendMoveCommand(mac, [operation: 2]) }
def sendTargetCommand(mac, position) { sendMoveCommand(mac, [targetPosition: position]) }
def sendAngleCommand(mac, angle)     { sendMoveCommand(mac, [targetAngle: angle]) }

// ------------------- Polling -------------------
def schedulePolling() {
    unschedule("pollChildren")
    switch (pollInterval ?: 5) {
        case 1: runEvery1Minute("pollChildren"); break
        case 5: runEvery5Minutes("pollChildren"); break
        case 10: runEvery10Minutes("pollChildren"); break
        case 15: runEvery15Minutes("pollChildren"); break
        case 30: runEvery30Minutes("pollChildren"); break
        case 60: runEvery1Hour("pollChildren"); break
        default: runEvery5Minutes("pollChildren")
    }
}

def pollChildren() {
    getChildDevices().each { requestStatus(it.deviceNetworkId) }
}
