//Ver4.0

import groovy.json.JsonSlurper

metadata {
    definition(name: "Connector Bridge (HTTP)", namespace: "Connector", author: "ScubaMikeJax904") {
        capability "Refresh"
        command "refreshDevices"
        command "pingBridge"
        attribute "bridgeStatus", "string"
        attribute "lastDiscovery", "string"
    }
}

preferences {
    input name: "serverIP", type: "string", title: "Node.js Server IP", required: true
    input name: "serverPort", type: "number", title: "Node.js Server Port", defaultValue: 3069, required: true
    input name: "pollInterval", type: "number", title: "Polling interval (minutes)", defaultValue: 5, required: true
    input name: "pingInterval", type: "number", title: "Bridge health check interval (minutes)", defaultValue: 1, required: true
    input name: "logEnable", type: "bool", title: "Enable Debug Logging?", defaultValue: true
}

// ------------------- Initialization -------------------
def installed() {
    refreshDevices()
    schedulePolling()
    schedulePing()
}

def updated() {
    unschedule()
    refreshDevices()
    schedulePolling()
    schedulePing()
}

def refresh() {
    refreshDevices()
}

// ------------------- Bridge Ping / Health -------------------
def pingBridge() {
    if (!serverIP || !serverPort) return
    if (logEnable) log.debug "Pinging Node.js bridge..."
    def url = "http://${serverIP}:${serverPort}/health"
    try {
        httpGet(uri: url, timeout: 20) { resp ->
            if(resp.status == 200 && resp.data?.status == "ok") {
                if (logEnable) log.debug "Bridge ping OK"
                sendEvent(name: "bridgeStatus", value: "ok")
                getChildDevices().each { it.sendEvent(name: "online", value: "online") }
            } else {
                log.warn "Bridge ping returned HTTP ${resp.status} or degraded status"
                sendEvent(name: "bridgeStatus", value: "offline")
                getChildDevices().each { it.markOffline() }
            }
        }
    } catch(Exception e) {
        log.error "Bridge ping error: ${e.message}"
        sendEvent(name: "bridgeStatus", value: "offline")
        getChildDevices().each { it.markOffline() }
    }
}

def schedulePing() {
    def minutes = pingInterval ?: 1
    if (logEnable) log.debug "Scheduling bridge ping every ${minutes} minute(s)"
    unschedule("pingBridge")
    switch(minutes) {
        case 1: runEvery1Minute("pingBridge"); break
        case 5: runEvery5Minutes("pingBridge"); break
        case 10: runEvery10Minutes("pingBridge"); break
        case 15: runEvery15Minutes("pingBridge"); break
        case 30: runEvery30Minutes("pingBridge"); break
        case 60: runEvery1Hour("pingBridge"); break
        default:
            log.warn "Unsupported pingInterval=${minutes}, defaulting to 5 minutes"
            runEvery5Minutes("pingBridge")
    }
}

// ------------------- Device Discovery -------------------
def refreshDevices() {
    if (logEnable) log.debug "Refreshing devices from Node.js server"
    if (!serverIP || !serverPort) {
        log.error "Server IP or Port not set"
        return
    }

    def url = "http://${serverIP}:${serverPort}/devices"
    try {
        httpGet(uri: url, timeout: 20) { resp ->
            if(resp.status == 200 && resp.data?.devices) {
                def deviceMap = resp.data.devices
                deviceMap.each { mac, deviceInfo ->
                    if(!mac) return

                    if(logEnable) log.debug "Found device with MAC: ${mac}"

                    def child = getChildDevice(mac)
                    if(!child) {
                        if(logEnable) log.debug "Creating child device ${mac}"
                        addChildDevice(
                            "Connector",
                            "Connector Bridge Roller Child",
                            mac,
                            [label: "Blind ${mac}", isComponent: false]
                        )
                    }

                    // Request initial status
                    requestStatus(mac)
                }

                sendEvent(
                    name: "lastDiscovery",
                    value: new Date().format("yyyy-MM-dd HH:mm:ss", location.timeZone)
                )
            } else {
                log.warn "No devices found in server response"
                sendEvent(name: "bridgeStatus", value: "offline")
            }
        }
    } catch(Exception e) {
        log.error "Cannot refresh devices: ${e.message}"
        sendEvent(name: "bridgeStatus", value: "offline")
    }
}

// ------------------- Status Request -------------------
def requestStatus(mac) {
    def url = "http://${serverIP}:${serverPort}/status/${mac}"
    if(logEnable) log.debug "Requesting status for ${mac}"

    try {
        httpGet(uri: url, timeout: 20) { resp ->
            if(resp.status == 200 && resp.data) {
                updateChildState(mac, resp.data)
            } else {
                log.warn "Failed to get status for ${mac}: HTTP ${resp.status}"
            }
        }
    } catch(Exception e) {
        log.warn "Status request error for ${mac}: ${e.message}"
    }
}

// ------------------- Child State Update -------------------
def updateChildState(mac, data) {
    def child = getChildDevice(mac)
    if(child) {
        child.updateStateFromParent(data)
        if(logEnable) {
            def deviceData = data.data ?: [:]
            def pos = deviceData.currentPosition != null ? "${deviceData.currentPosition}%" : "?"
            def batt = deviceData.batteryLevel != null ? "${deviceData.batteryLevel}%" : "?"
            def shadeState = child.currentValue("windowShade") ?: "?"
            log.debug "Updated ${child.displayName} â†’ pos=${pos}, shade=${shadeState}, battery=${batt}"
        }
    }
}

// ------------------- Device Commands -------------------
def sendOpenCommand(mac) {
    def url = "http://${serverIP}:${serverPort}/open/${mac}"
    if(logEnable) log.debug "Sending open command to ${mac}"
    
    try {
        httpGet(uri: url, timeout: 20) { resp ->
            if(logEnable) log.debug "Open command response for ${mac}: HTTP ${resp.status}"
        }
    } catch(Exception e) {
        log.error "Open command error for ${mac}: ${e.message}"
    }
}

def sendCloseCommand(mac) {
    def url = "http://${serverIP}:${serverPort}/close/${mac}"
    if(logEnable) log.debug "Sending close command to ${mac}"
    
    try {
        httpGet(uri: url, timeout: 20) { resp ->
            if(logEnable) log.debug "Close command response for ${mac}: HTTP ${resp.status}"
        }
    } catch(Exception e) {
        log.error "Close command error for ${mac}: ${e.message}"
    }
}

def sendStopCommand(mac) {
    def url = "http://${serverIP}:${serverPort}/stop/${mac}"
    if(logEnable) log.debug "Sending stop command to ${mac}"
    
    try {
        httpGet(uri: url, timeout: 20) { resp ->
            if(logEnable) log.debug "Stop command response for ${mac}: HTTP ${resp.status}"
        }
    } catch(Exception e) {
        log.error "Stop command error for ${mac}: ${e.message}"
    }
}

def sendTargetCommand(mac, position) {
    def url = "http://${serverIP}:${serverPort}/target/${mac}/${position}"
    if(logEnable) log.debug "Sending target position ${position} to ${mac}"
    
    try {
        httpGet(uri: url, timeout: 20) { resp ->
            if(logEnable) log.debug "Target command response for ${mac}: HTTP ${resp.status}"
        }
    } catch(Exception e) {
        log.error "Target command error for ${mac}: ${e.message}"
    }
}

// ------------------- Polling -------------------
def schedulePolling() {
    def minutes = pollInterval ?: 5
    if(logEnable) log.debug "Scheduling polling every ${minutes} minute(s)"
    unschedule("pollChildren")
    switch(minutes) {
        case 1: runEvery1Minute("pollChildren"); break
        case 5: runEvery5Minutes("pollChildren"); break
        case 10: runEvery10Minutes("pollChildren"); break
        case 15: runEvery15Minutes("pollChildren"); break
        case 30: runEvery30Minutes("pollChildren"); break
        case 60: runEvery1Hour("pollChildren"); break
        default:
            log.warn "Unsupported pollInterval=${minutes}, defaulting to 5 minutes"
            runEvery5Minutes("pollChildren")
    }
}

def pollChildren() {
    if(logEnable) log.debug "Polling all children..."
    getChildDevices().each { child ->
        requestStatus(child.deviceNetworkId)
    }
}
