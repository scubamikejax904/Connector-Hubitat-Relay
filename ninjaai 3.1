// ----- Imports -----
const express = require('express');
const dgram = require('dgram');
const { v4: uuidv4 } = require('uuid');
const winston = require('winston');
const crypto = require('crypto');

// ----- Configuration -----
const MULTICAST_ADDR = '238.0.0.18';
const PORT_IN = 32101;   // incoming UDP reports
const PORT_OUT = 32100;  // outgoing UDP commands
const BRIDGE_IP = process.env.BRIDGE_IP || '127.0.0.1';
const KEY = process.env.CONNECTOR_KEY;
const PORT_HTTP = process.env.PORT || 3069;
const DEVICE_TIMEOUT = parseInt(process.env.DEVICE_TIMEOUT || '60000', 10);
const MOTOR_DEVICE_TYPE = '10000000';

// ----- Logger -----
const logger = winston.createLogger({
    level: 'info',
    format: winston.format.json(),
    defaultMeta: { service: 'connector-service' },
    transports: [ new winston.transports.Console({ format: winston.format.json() }) ]
});

// ----- State -----
const devices = {};               // { normalizedMac: { data, lastSeen } }
let accessToken = null;
const pendingCommands = new Map(); // msgID â†’ { resolve, reject, timeout }

// ----- Utilities -----
function calculateAccessToken(key, token) {
    if (!key || key.length !== 16) {
        throw new Error(`Key must be 16 bytes for AES-128. Current length: ${key ? key.length : 0}`);
    }
    const cipher = crypto.createCipheriv('aes-128-ecb', Buffer.from(key, 'utf8'), null);
    cipher.setAutoPadding(false);
    const encrypted = Buffer.concat([cipher.update(Buffer.from(token, 'utf8')), cipher.final()]);
    return encrypted.toString('hex').toUpperCase();
}

function normalizeMAC(mac) {
    if (!mac) return null;
    return mac.replace(/[^A-Fa-f0-9]/g, '').toLowerCase(); // strip colons/hyphens
}

function isValidMAC(mac) {
    const nmac = normalizeMAC(mac);
    return nmac && nmac.length === 16;
}

function updateDeviceState(mac, data) {
    const nmac = normalizeMAC(mac);
    if (!nmac) return;
    if (!devices[nmac]) devices[nmac] = {};
    devices[nmac].data = data;
    devices[nmac].lastSeen = Date.now();
}

// ----- UDP Socket -----
const udpSocket = dgram.createSocket({ type: 'udp4', reuseAddr: true });

udpSocket.on('listening', () => {
    const address = udpSocket.address();
    logger.info(`UDP listening on ${address.port}`);
    udpSocket.addMembership(MULTICAST_ADDR);
});

udpSocket.on('message', (msg, rinfo) => {
    try {
        const data = JSON.parse(msg.toString());

        if (data.msgType === 'GetDeviceListAck' && data.mac === '0100000000000001') {
            logger.info('Received token from bridge');
            try {
                accessToken = calculateAccessToken(KEY, data.token);
                logger.info('Token updated:', { accessToken: !!accessToken, token: data.token, timestamp: new Date().toISOString() });
            } catch (err) {
                logger.error(`Error calculating AccessToken: ${err.message}`, { stack: err.stack });
            }
            return;
        }

        if (['Report', 'WriteDeviceAck', 'ReadDeviceAck'].includes(data.msgType)) {
            const nmac = normalizeMAC(data.mac);
            updateDeviceState(nmac, data.data);
            logger.info(`${data.msgType} for ${nmac}:`, data.data);

            if (data.msgID && pendingCommands.has(data.msgID)) {
                const { resolve, timeout } = pendingCommands.get(data.msgID);
                clearTimeout(timeout);
                pendingCommands.delete(data.msgID);
                resolve(data);
            }
        }
    } catch (err) {
        logger.error('Error parsing UDP message', { error: err.message });
    }
});

// ----- Express API -----
const app = express();
app.use(express.json());

// Normalize MAC param
app.param('mac', (req, res, next, mac) => {
    const nmac = normalizeMAC(mac);
    if (!isValidMAC(nmac)) {
        return res.status(400).json({ error: 'Invalid MAC address' });
    }
    req.mac = nmac;
    next();
});

// Device list
app.get('/devices', (req, res) => {
    res.json(devices);
});

// Get device status
app.get('/status/:mac', async (req, res) => {
    try {
        if (!devices[req.mac]) {
            return res.status(404).json({ error: 'Device not found', known: Object.keys(devices) });
        }
        const response = await sendCommand(req.mac, { operation: 5 });
        res.json(response);
    } catch (err) {
        res.status(500).json({ error: err.message });
    }
});

// Control endpoints
app.post('/open/:mac', async (req, res) => {
    try {
        const response = await sendCommand(req.mac, { operation: 1 });
        res.json(response);
    } catch (err) {
        res.status(500).json({ error: err.message });
    }
});

app.post('/close/:mac', async (req, res) => {
    try {
        const response = await sendCommand(req.mac, { operation: 0 });
        res.json(response);
    } catch (err) {
        res.status(500).json({ error: err.message });
    }
});

app.post('/stop/:mac', async (req, res) => {
    try {
        const response = await sendCommand(req.mac, { operation: 2 });
        res.json(response);
    } catch (err) {
        res.status(500).json({ error: err.message });
    }
});

app.post('/target/:mac/:position', async (req, res) => {
    try {
        let targetPosition = parseInt(req.params.position, 10);
        if (isNaN(targetPosition) || targetPosition < 0 || targetPosition > 100) {
            return res.status(400).json({ error: 'Invalid position' });
        }
        const response = await sendCommand(req.mac, { targetPosition });
        res.json(response);
    } catch (err) {
        res.status(500).json({ error: err.message });
    }
});

// ----- Command Sender -----
async function sendCommand(mac, data, retries = 0) {
    if (!accessToken) {
        throw new Error('AccessToken not ready yet');
    }
    const nmac = normalizeMAC(mac);

    const payload = {
        msgType: 'WriteDevice',
        mac: nmac,
        deviceType: MOTOR_DEVICE_TYPE,
        msgID: uuidv4(),
        AccessToken: accessToken,
        data
    };

    return new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
            if (retries < 3) {
                logger.warn(`Retrying command for ${nmac}, attempt ${retries + 1}`);
                sendCommand(nmac, data, retries + 1).then(resolve).catch(reject);
            } else {
                pendingCommands.delete(payload.msgID);
                reject(new Error(`Command timeout for ${nmac}`));
            }
        }, 2000);

        pendingCommands.set(payload.msgID, { resolve, reject, timeout });

        const msgBuffer = Buffer.from(JSON.stringify(payload));
        udpSocket.send(msgBuffer, 0, msgBuffer.length, PORT_OUT, BRIDGE_IP, (err) => {
            if (err) {
                clearTimeout(timeout);
                pendingCommands.delete(payload.msgID);
                reject(err);
            }
        });
    });
}

// ----- Device Cleanup -----
setInterval(() => {
    const now = Date.now();
    for (const [mac, device] of Object.entries(devices)) {
        if (now - device.lastSeen > DEVICE_TIMEOUT) {
            logger.info(`Removing stale device ${mac}`);
            delete devices[mac];
        }
    }
}, 30000);

// ----- Startup -----
async function startServices() {
    udpSocket.bind(PORT_IN);

    app.listen(PORT_HTTP, () => {
        logger.info(`HTTP API running at http://localhost:${PORT_HTTP}`);
    });

    // Request token from bridge
    const payload = {
        msgType: 'GetDeviceList',
        mac: '0100000000000001',
        msgID: uuidv4()
    };
    const msgBuffer = Buffer.from(JSON.stringify(payload));
    udpSocket.send(msgBuffer, 0, msgBuffer.length, PORT_OUT, BRIDGE_IP);
    logger.info('Waiting for token from bridge...');
}

function gracefulShutdown(signal) {
    logger.info(`Received ${signal}, shutting down gracefully...`);
    udpSocket.close(() => {
        logger.info('UDP socket closed.');
        process.exit(0);
    });
}

process.on('SIGINT', () => gracefulShutdown('SIGINT'));
process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));

startServices();
